1. 模块的加载机制
```js
在 Node.js 中模块加载一般会经历 3 个步骤，路径分析、文件定位、编译执行。

按照模块的分类，按照以下顺序进行优先加载：

系统缓存：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。
系统模块：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 路径分析、文件定位，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。
文件模块：优先加载 .、..、/ 开头的，如果文件没有加上扩展名，会依次按照 .js、.json、.node 进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在，从性能优化的角度来看待，.json、.node最好还是加上文件的扩展名。
目录做为模块：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个 包 来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 ("main": "lib/hello.js") 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module 'lib/hello.js'
node_modules 目录加载：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录。
```

2. 循环引用

(官网解释)[https://nodejs.org/api/modules.html#modules_cycles]

为了防止模块载入的死循环，Node.js 在模块第一次载入后会把它的结果进行缓存，下一次再对它进行载入的时候会直接从缓存中取出结果。所以在这种循环依赖情形下，不会有死循环，但是却会因为缓存造成模块没有按照我们预想的那样被导出。

可以在循环依赖的每个模块中先导出自身，然后再导入其他模块来解决这个问题。

3. 对象引用关系考察，module.exports与exports的区别
   
exports 相当于 module.exports 的快捷方式
```js
const exports = modules.exports;
```
但是要注意不能改变 exports 的指向，我们可以通过 exports.test = 'a' 这样来导出一个对象, 但是不能向下面示例直接赋值，这样会改变 exports 的指向
```js
// 错误的写法 将会得到 undefined
exports = {
  'a': 1,
  'b': 2
}

// 正确的写法
modules.exports = {
  'a': 1,
  'b': 2
}
```

4. 对buffer的理解
  
Buffer 用于读取或操作二进制数据流，做为 Node.js API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且是无法调整的。

5. child_process和cluster的区别

The child_process module provides the ability to spawn subprocesses in a manner that is similar, but not identical, to popen(3). This capability is primarily provided by the child_process.spawn() function:

The cluster module allows easy creation of child processes that all share server ports.

```js
集群模式实现通常有两种方案：

方案一：1 个 Node 实例开启多个端口，通过反向代理服务器向各端口服务进行转发
方案二：1 个 Node 实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master->Worker）
首先第一种方案存在的一个问题是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做，好处是稳定性高，各实例之间无影响。

第二个方案多个 Node 进程去监听同一个端口，好处是进程间通信相对简单、减少了端口的资源浪费，但是这个时候就要保证服务进程的稳定性了，特别是对 Master 进程稳定性要求会更高，编码也会复杂。

在 Nodejs 中自带的 Cluster 模块正是采用的第二种方案。
```

```js
child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。
child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。
child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为
child_process.fork()： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。
```

6. console.log是异步的吗

```js
var a = {b:{c:1}};
console.log(a); // node.js环境下输出{ b: { c: 1 } }，在webkit浏览器环境(如chrome)下输出{ b: { c: 2 } }
a.b.c = 2;
```

虽然看上去如注释所说，其实我们在webkit浏览器下看到的并不是console.log真正的输出，而是展开时，浏览器拿到的最新的对象。

console.log 执行的时候，chrome 会对 log 的对象求一次值，打印出来是 Object ，可以继续展开的。但当你展开控制台中的 Object 的时候，chrome 又会对它求一次值，这一次是显示它的属性。所以才会有前后打印的东西不一样的情况发生，因为对象引用的实体的值改变了。
如果把 console.log(a) 改为 console.log(JSON.stringify(a))， 这时就会输出{"b":{"c":1}}是刚开始期望的结果。

也就是说WebKit的console.log并没有立即拍摄对象快照，相反，它只存储了一个指向对象的引用，然后在代码返回事件队列时才去拍摄快照。

```js
var a = {
  index: 1
}
console.log(a)   // 在chrome中会打印出{index: 1}，但是展开对象时显示index: 2
a.index++
```

这个例子可以看出{index: 1}是真正的打印对象，而展开后，浏览器拿到对象的最新的值2。

像node.js文档中所说
> Warning: The global console object's methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the note on [process I/O](https://nodejs.org/dist/latest-v14.x/docs/api/process.html#process_a_note_on_process_i_o) for more information.

并没有什么规范或一组需求指定console.* 方法族如何工作——它们并不是JavaScript 正式的一部分，而是由宿主环境添加到JavaScript 中的。因此，不同的浏览器和JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。
尤其要提出的是，在某些条件下，某些浏览器的console.log(..) 并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O 是非常低速的阻塞部分。所以，（从页面/UI 的角度来说）浏览器在后台异步处理控制台I/O 能够提高性能，这时用户甚至可能根本意识不到其发生。

总结，console.log 是同步的，与异步完全无关。但是，console.log 打印一个对象的时候，打印的字符串只会打印对象的第一层，而展开后会直接从内存里读取该对象，因此，展开的对象读取的是这个对象的最新值（这一点往往造成 debug 时的诸多困惑，很坑，但是如果打印整个对象会大大降低 console.log 的性能，所以 chrome 不得不这么做）。对于一般基本类型的调试，调试时使用console.log来输出内容时，不会存在坑。但调试对象时，最好还是使用打断点(debugger)这样的方式来调试更好。

7. __dirname，__filename，process.cwd()区别，为什么可以直接调用
- __dirname：    获得当前执行文件所在目录的完整目录名
- __filename：   获得当前执行文件的带有完整绝对路径的文件名
- process.cwd()：获得当前执行node命令时候的文件夹目录名 
- ./：           文件所在目录

8. node查看内存
process.memoryUsage()

9. node内存泄漏产生

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

- 全局变量

未声明的变量或挂在全局 global 下的变量不会自动回收，将会常驻内存直到进程退出才会被释放，除非通过 delete 或 重新赋值为 undefined/null 解决之间的引用关系，才会被回收。关于全局变量上面举的几个例子中也有说明。

- 闭包

这个也是一个常见的内存泄漏情况，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄漏。

- 慎将内存做为缓存

通过内存来做缓存这可能是我们想到的最快的实现方式，另外业务中缓存还是很常用的，但是了解了 Node.js 中的内存模型和垃圾回收机制之后在使用的时候就要谨慎了，为什么呢？缓存中存储的键越多，长期存活的对象也就越多,垃圾回收时将会对这些对对象做无用功。

10.   如何预防xss攻击

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

[美团技术团队-如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)

11.   websocket、http、tcp的区别

12.   sleep()如何实现

13.   express、koa、egg的区别

14.   描述下egg的洋葱模型

15.   进程间通信方式
- 管道
- 信号量
- 消息队列
- 共享内存
- socket

16. setTimeout、setInterval和setImmediate的区别  

[Node.js 事件循环，定时器和 process.nextTick()](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)

17. gc机制

几种垃圾回收算法：
- 引用计数法

引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短

优点

可即刻回收垃圾
最大暂停时间短
没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找
缺点

计数器的增减处理繁重
计数器需要占用很多位
实现繁琐复杂， 每个赋值操作都得替换成引用更新操作
循环引用无法回收

- 标记清除

标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

标记清除法利用到了堆、链表结构 标记阶段：从根集合出发，将所有活动对象及其子对象打上标记 清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

优点

实现简单， 容易和其他算法组合

缺点

碎片化， 会导致无数小分块散落在堆的各处
分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
与写时复制技术不兼容，因为每次都会在活动对象上打上标记

- 标记压缩

和"标记－清除"相似，不过在标记阶段后它将所有活动对象紧密的排在堆的一侧（压缩），消除了内存碎片， 不过压缩是需要花费计算成本的。

优点

有效利用了堆，不会出现内存碎片 也不会像复制算法那样只能利用堆的一部分

缺点

压缩过程的开销，需要多次搜索堆

- gc复制算法

将堆分为两个大小相同的空间 From 和 To， 利用 From 空间进行分配，当 From 空间满的时候，GC将其中的活动对象复制到 To 空间，之后将两个空间互换即完成GC。

优点

优秀的吞吐量， 只需要关心活动对象
可实现高速分配； 因为分块是连续的，不需要使用空闲链表
不会发生碎片化
与缓存兼容
缺点

堆使用率低
与保守式GC不兼容
递归调用函数， 复制子对象需要递归调用复制函数 消耗栈

- 分代回收

出发点：大部分对象生成后马上就变成垃圾，很少有对象能活的很久

新生代 = 生成空间 + 2 * 幸存区 复制算法

老年代 标记-清除算法

对象在生成空间创建，当生成空间满之后进行 minor gc，将活动对象复制到第一个幸存区，并增加其“年龄” age，当这个幸存区满之后再将此次生成空间和这个幸存区的活动对象复制到另一个幸存区，如此反复，当活动对象的 age 达到一定次数后将其移动到老年代； 当老年代满的时候就用标记-清除或标记-压缩算法进行major gc。

吞吐量得到改善，分代垃圾回收花费的时间是GC复制算法的四分之一；但是如果部分程序新生成对象存活很久的话分代回收会适得其反。

- 增量式gc，三色标记法

本来gc只是默默的在幕后回收资源的，但是如果gc任务繁重则会长时间暂停应用程序的执行， 增量式gc就是一种逐渐推进垃圾回收来控制mutator最大暂停时间的方法

白色： 还未搜索过的对象
灰色： 正在搜索的对象
黑色： 搜索完成的对象
根查找阶段： 对能直接从根引用的对象打上标记，堆放到标记栈里（白色 涂成 灰色）

标记阶段： 从标记栈中取出对象，将其子对象涂成灰色；这个阶段不是一下子处理所有的灰色对象，而只是处理一定个数，然后暂停gc

清除阶段： 将没被标记的白色对象连接到空闲链表，并重置已标记的对象标记位

优点： 缩短最大暂停时间
缺点： 降低了吞吐量

18.    什么是反向代理

正向代理其实是客户端的代理,反向代理则是服务器的代理。  
正向代理中，服务器并不知道真正的客户端到底是谁；而在反向代理中，客户端也不知道真正的服务器是谁。  
作用不同: 正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用。